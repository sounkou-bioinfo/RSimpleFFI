# Dynamic library loading using R's native facilities

#' Load a shared library/DLL
#' 
#' @param filename Path to the shared library
#' @param now Whether to resolve all symbols immediately (default TRUE)
#' @param local Keep symbols local to avoid namespace pollution (default TRUE)
#' @param verbose Print loading information (default FALSE)
#' @return Library handle (character string of loaded library path)
#' @export
dll_load <- function(filename, now = TRUE, local = TRUE, verbose = FALSE) {
  if (!file.exists(filename)) {
    stop("Library file not found: ", filename)
  }
  
  # Use R's built-in dyn.load
  result <- tryCatch({
    dyn.load(filename, now = now, local = local, verbose = verbose)
    filename  # Return the filename as handle
  }, error = function(e) {
    stop("Failed to load library '", filename, "': ", e$message)
  })
  
  if (verbose) {
    message("Successfully loaded library:", filename, "\n")
  }
  
  result
}

#' Unload a shared library/DLL
#' 
#' @param handle Library handle (path) returned by dll_load()
#' @param verbose Print unloading information (default FALSE)
#' @export
dll_unload <- function(handle, verbose = FALSE) {
  if (!is.character(handle)) {
    stop("Handle must be a character string (library path)")
  }
  
  result <- tryCatch({
    dyn.unload(handle)
    if (verbose) {
      message("Successfully unloaded library:", handle, "\n")
    }
    TRUE
  }, error = function(e) {
    warning("Failed to unload library '", handle, "': ", e$message)
    FALSE
  })
  
  invisible(result)
}

#' Get symbol information from a loaded library
#' 
#' @param symbol_name Name of the symbol to find
#' @param package Package name where symbol is registered (optional)
#' @return Symbol information including address as external pointer
#' @export
dll_symbol <- function(symbol_name, package = NULL) {
  if (!is.character(symbol_name) || length(symbol_name) != 1) {
    stop("Symbol name must be a single character string")
  }
  
  # Try to get symbol info
  symbol_info <- tryCatch({
    if (is.null(package)) {
      getNativeSymbolInfo(symbol_name)
    } else {
      getNativeSymbolInfo(symbol_name, package)
    }
  }, error = function(e) {
    stop("Symbol '", symbol_name, "' not found: ", e$message)
  })
  
  if (is.null(symbol_info$address)) {
    stop("Symbol '", symbol_name, "' has NULL address")
  }
  
  symbol_info
}

#' Check if a symbol is loaded
#' 
#' @param symbol_name Name of the symbol to check
#' @param package Package name (optional)
#' @return TRUE if symbol is loaded, FALSE otherwise
#' @export
dll_is_loaded <- function(symbol_name, package = NULL) {
  if (!is.character(symbol_name) || length(symbol_name) != 1) {
    stop("Symbol name must be a single character string")
  }
  
  tryCatch({
    if (is.null(package)) {
      is.loaded(symbol_name)
    } else {
      is.loaded(symbol_name, PACKAGE = package)
    }
  }, error = function(e) {
    FALSE
  })
}

#' Create FFI function from dynamically loaded function
#' 
#' This creates an FFI function wrapper for dynamically loaded native C functions.
#' Uses direct address access like Rffi for maximum compatibility.
#' 
#' @param symbol_name Name of the symbol
#' @param return_type Return type specifimessageion
#' @param ... Argument type specifimessageions  
#' @param package Package name (optional)
#' @return FFI function object that can be called directly
#' @export
dll_ffi_symbol <- function(symbol_name, return_type, ..., package = NULL) {
  # Get symbol info using R's facilities (like Rffi does)
  symbol_info <- dll_symbol(symbol_name, package)
  
  # Create CIF for the function signature
  cif <- ffi_cif(return_type, ...)
  
  # Create symbol object from address
  symbol <- ffi_symbol_from_address(symbol_info$address, symbol_name)
  
  # Return a closure that calls the function
  function(...) {
    ffi_call(cif, symbol, ...)
  }
}

#' List loaded libraries
#' 
#' @return Character vector of loaded library paths
#' @export
dll_list_loaded <- function() {
  # Get currently loaded DLLs
  loaded <- getLoadedDLLs()
  vapply(loaded, function(x) x[["path"]], character(1))
}

#' Get information about a loaded library
#' 
#' @param handle Library handle (path)
#' @return List with library information
#' @export
dll_info <- function(handle) {
  if (!is.character(handle)) {
    stop("Handle must be a character string (library path)")
  }
  
  loaded <- getLoadedDLLs()
  
  # Find the library by path
  lib_info <- NULL
  for (dll in loaded) {
    if (dll[["path"]] == handle) {
      lib_info <- dll
      break
    }
  }
  
  if (is.null(lib_info)) {
    stop("Library not found in loaded DLLs: ", handle)
  }
  
  list(
    name = lib_info[["name"]],
    path = lib_info[["path"]],
    dynamicLookup = lib_info[["DLLInfo"]][["dynamicLookup"]],
    handle = lib_info[["DLLInfo"]][["handle"]]
  )
}

#' Compile and load C code dynamically
#' 
#' @param code C code as character string
#' @param name Base name for temporary files (default "temp_dll")
#' @param includes Additional include directories
#' @param libs Additional libraries to link
#' @param verbose Print compilation output (default FALSE)
#' @return Library handle that can be used with dll_* functions
#' @export
dll_compile_and_load <- function(code, name = "temp_dll", includes = NULL, libs = NULL, verbose = FALSE) {
  # Create temporary files
  temp_dir <- tempdir()
  c_file <- file.path(temp_dir, paste0(name, ".c"))
  so_file <- file.path(temp_dir, paste0(name, .Platform$dynlib.ext))
  
  # Write C code to file
  writeLines(code, c_file)
  
  # Build R CMD SHLIB command using R's compiler configuration
  r_home <- R.home()
  r_cmd <- file.path(r_home, "bin", "R")
  
  cmd_args <- c("CMD", "SHLIB", "-o", so_file)
  
  if (!is.null(includes)) {
    include_flags <- paste0("-I", includes, collapse = " ")
    cmd_args <- c(cmd_args, paste0("PKG_CPPFLAGS=", include_flags))
  }
  
  if (!is.null(libs)) {
    lib_flags <- paste0("-l", libs, collapse = " ")
    cmd_args <- c(cmd_args, paste0("PKG_LIBS=", lib_flags))
  }
  
  cmd_args <- c(cmd_args, c_file)
  
  # Set up environment variables for compilation
  env_vars <- character(0)
  if (!is.null(libs)) {
    lib_flags <- paste0("-l", libs, collapse = " ")
    env_vars <- c(env_vars, paste0("PKG_LIBS=", lib_flags))
    # Remove PKG_LIBS from cmd_args since it should be an env var
    cmd_args <- cmd_args[!grepl("^PKG_LIBS=", cmd_args)]
  }
  
  # Compile using R's configured compiler
  if (verbose) {
    if (length(env_vars) > 0) {
      # Use withr to set environment variables temporarily
      old_env <- Sys.getenv(names(env_vars), unset = NA)
      on.exit({
        for (i in seq_along(env_vars)) {
          var_name <- sub("=.*", "", env_vars[i])
          var_value <- old_env[i]
          if (is.na(var_value)) {
            Sys.unsetenv(var_name)
          } else {
            Sys.setenv(setNames(var_value, var_name))
          }
        }
      })
      # Set the environment variables
      for (env_var in env_vars) {
        parts <- strsplit(env_var, "=", fixed = TRUE)[[1]]
        env_list <- list()
        env_list[[parts[1]]] <- parts[2]
        do.call(Sys.setenv, env_list)
      }
    }
    output <- system2(r_cmd, cmd_args, stdout = TRUE, stderr = TRUE)
    result <- attr(output, "status")
    if (is.null(result)) result <- 0
    if (result != 0) {
      message("Compilation output:\n")
      message(paste(output, collapse = "\n"), "\n")
    }
  } else {
    if (length(env_vars) > 0) {
      # Set environment variables for non-verbose mode too
      old_env <- Sys.getenv(names(env_vars), unset = NA)
      on.exit({
        for (i in seq_along(env_vars)) {
          var_name <- sub("=.*", "", env_vars[i])
          var_value <- old_env[i]
          if (is.na(var_value)) {
            Sys.unsetenv(var_name)
          } else {
            Sys.setenv(setNames(var_value, var_name))
          }
        }
      })
      for (env_var in env_vars) {
        parts <- strsplit(env_var, "=", fixed = TRUE)[[1]]
        env_list <- list()
        env_list[[parts[1]]] <- parts[2]
        do.call(Sys.setenv, env_list)
      }
    }
    result <- system2(r_cmd, cmd_args, stdout = FALSE, stderr = FALSE)
  }
  
  if (result != 0) {
    stop("Compilation failed with status ", result)
  }
  
  if (!file.exists(so_file)) {
    stop("Shared library not created: ", so_file)
  }
  
  # Load the library
  dll_load(so_file, verbose = verbose)
}

#' Load system library (like libc, libm, etc.)
#' 
#' @param lib_name Name of system library (e.g., "c", "m", "pthread")
#' @param verbose Print loading information (default FALSE)
#' @return Library handle or NULL if not found
#' @export
dll_load_system <- function(lib_name, verbose = FALSE) {
  # Common system library paths
  system_paths <- c(
    paste0("/lib/x86_64-linux-gnu/lib", lib_name, ".so.6"),    # Ubuntu/Debian libc
    paste0("/lib/x86_64-linux-gnu/lib", lib_name, ".so"),      # Other libs
    paste0("/usr/lib/x86_64-linux-gnu/lib", lib_name, ".so"),  # Alternative path
    paste0("/lib64/lib", lib_name, ".so.6"),                   # RedHat/CentOS libc
    paste0("/lib64/lib", lib_name, ".so"),                     # Other libs
    paste0("/usr/lib64/lib", lib_name, ".so"),                 # Alternative
    paste0("/usr/lib/lib", lib_name, ".so"),                   # Generic
    paste0("lib", lib_name, ".so")                              # Just try the name
  )
  
  # Try each path
  for (path in system_paths) {
    if (file.exists(path)) {
      tryCatch({
        result <- dll_load(path, verbose = verbose)
        if (verbose) {
          message("Successfully loaded system library:", path, "\n")
        }
        return(result)
      }, error = function(e) {
        if (verbose) {
          message("Failed to load", path, ":", e$message, "\n")
        }
      })
    }
  }
  
  # If direct paths fail, try using dlopen with RTLD_DEFAULT
  # This works for already-loaded system libraries
  tryCatch({
    # Most system libraries are already loaded in the process
    if (lib_name == "c") {
      # libc is always available - return a special marker
      return("SYSTEM_LIBC")
    }
    stop("Library not found")
  }, error = function(e) {
    warning("System library '", lib_name, "' not found or not accessible")
    return(NULL)
  })
}