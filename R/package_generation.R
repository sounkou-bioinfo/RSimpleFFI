# Generate Package Initialization Code for Library Loading

#' Generate .onLoad/.onUnload for package
#' 
#' Creates the zzz.R file content for loading external libraries
#' 
#' @param library_name Name of the shared library (e.g., "mylib")
#' @param package_name Name of the R package
#' @param library_path Optional: specific path to library, or NULL for system search
#' @param use_system_lib Logical: search system library paths
#' @return Character string with zzz.R content
#' @export
#' @examples
#' \dontrun{
#' # Generate for system library
#' code <- generate_package_init("mylib", "MyRPackage", use_system_lib = TRUE)
#' writeLines(code, "R/zzz.R")
#' 
#' # Generate for bundled library
#' code <- generate_package_init("mylib", "MyRPackage", use_system_lib = FALSE)
#' }
generate_package_init <- function(library_name, 
                                   package_name,
                                   library_path = NULL,
                                   use_system_lib = TRUE) {
  
  if (use_system_lib) {
    load_code <- sprintf('  .%s_lib <<- dll_load_system("%s%s")', 
                         library_name,
                         library_name,
                         .Platform$dynlib.ext)
  } else if (!is.null(library_path)) {
    load_code <- sprintf('  .%s_lib <<- dll_load("%s")', 
                         library_name,
                         library_path)
  } else {
    # Package-bundled library
    load_code <- sprintf(
'  lib_file <- system.file("libs", 
                          paste0("%s", .Platform$dynlib.ext), 
                          package = pkgname)
  if (file.exists(lib_file)) {
    .%s_lib <<- dll_load(lib_file)
  } else {
    warning("Library file not found: ", lib_file)
  }',
      library_name, library_name
    )
  }
  
  code <- sprintf(
'# Package initialization and cleanup
# Auto-generated by RSimpleFFI

# Global variable to store library handle
.%s_lib <- NULL

#\' @keywords internal
.onLoad <- function(libname, pkgname) {
%s
}

#\' @keywords internal
.onUnload <- function(libpath) {
  if (!is.null(.%s_lib)) {
    dll_unload(.%s_lib)
  }
}
',
    library_name,
    load_code,
    library_name,
    library_name
  )
  
  code
}

#' Generate complete package from header files
#' 
#' Creates all necessary R files for a package wrapping a C library
#' 
#' @param header_files Character vector of header file paths
#' @param package_name Name of the R package
#' @param library_name Name of the shared library
#' @param output_dir Directory to write generated files
#' @param use_system_lib Logical: search system library paths
#' @param include_helpers Logical: include allocation helper functions
#' @return Invisibly returns list of generated files
#' @export
#' @examples
#' \dontrun{
#' generate_package_from_headers(
#'   header_files = c("mylib.h", "mylib_utils.h"),
#'   package_name = "MyRPackage",
#'   library_name = "mylib",
#'   output_dir = "MyRPackage/R",
#'   use_system_lib = TRUE
#' )
#' }
generate_package_from_headers <- function(header_files,
                                           package_name,
                                           library_name,
                                           output_dir = "R",
                                           use_system_lib = TRUE,
                                           include_helpers = TRUE) {
  
  if (!dir.exists(output_dir)) {
    dir.create(output_dir, recursive = TRUE)
  }
  
  generated_files <- character()
  
  # 1. Generate zzz.R for library loading
  cat("Generating package initialization (zzz.R)...\n")
  zzz_code <- generate_package_init(library_name, package_name, use_system_lib = use_system_lib)
  zzz_file <- file.path(output_dir, "zzz.R")
  writeLines(zzz_code, zzz_file)
  generated_files <- c(generated_files, zzz_file)
  
  # 2. Parse each header and generate bindings
  all_bindings <- list()
  
  for (header_file in header_files) {
    cat("Processing header:", header_file, "\n")
    
    if (!file.exists(header_file)) {
      warning("Header file not found: ", header_file)
      next
    }
    
    parsed <- ffi_parse_header(header_file)
    base_name <- tools::file_path_sans_ext(basename(header_file))
    
    # Generate bindings
    bindings_code <- generate_r_bindings(parsed)
    bindings_file <- file.path(output_dir, paste0(base_name, "_bindings.R"))
    writeLines(bindings_code, bindings_file)
    generated_files <- c(generated_files, bindings_file)
    
    all_bindings[[base_name]] <- parsed
  }
  
  # 3. Generate helper functions if requested
  if (include_helpers) {
    cat("Generating helper functions...\n")
    helpers_file <- file.path(output_dir, "helpers.R")
    
    # Copy helpers.R content
    helpers_template <- '
# Helper functions for struct manipulation

#\' Create struct from list
#\' @export
create_struct_from_list <- function(struct_type, values) {
  ptr <- ffi_alloc(struct_type)
  for (field_name in names(values)) {
    if (field_name %in% struct_type@fields) {
      ffi_set_field(ptr, field_name, values[[field_name]], struct_type)
    }
  }
  ptr
}

#\' Convert struct to list
#\' @export
struct_to_list <- function(ptr, struct_type) {
  result <- list()
  for (field_name in struct_type@fields) {
    result[[field_name]] <- ffi_get_field(ptr, field_name, struct_type)
  }
  result
}
'
    writeLines(helpers_template, helpers_file)
    generated_files <- c(generated_files, helpers_file)
  }
  
  # 4. Generate summary
  cat("\n========================================\n")
  cat("Package generation complete!\n")
  cat("========================================\n\n")
  cat("Generated files:\n")
  for (f in generated_files) {
    cat("  -", f, "\n")
  }
  cat("\nNext steps:\n")
  cat("1. Review generated R files in", output_dir, "\n")
  cat("2. Add DESCRIPTION file with dependencies: RSimpleFFI\n")
  cat("3. Generate NAMESPACE with: devtools::document()\n")
  cat("4. Build package: R CMD build\n")
  cat("5. Install: R CMD INSTALL\n\n")
  
  invisible(list(
    files = generated_files,
    bindings = all_bindings
  ))
}
