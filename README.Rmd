---
output: github_document
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  out.width = "100%"
)
```

# RSimpleFFI

<!-- badges: start -->
[![R-CMD-check](https://github.com/sounkou-bioinfo/RSimpleFFI/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/sounkou-bioinfo/RSimpleFFI/actions/workflows/R-CMD-check.yaml)
<!-- badges: end -->

A Simple Foreign Function Interface (FFI) for R using libffi.


## Overview

RSimpleFFI lets you call C functions from R using the [libffi](https://github.com/libffi/libffi) library. It supports over 25 different C types including integers, floats, and platform-specific types. The package uses S7 classes for type safety and handles memory management automatically. It only needs libffi which is available on most systems. RSimpleFFI is inspired by the [Rffi package](https://github.com/omegahat/Rffi/) by Duncan Temple Lang. It builds on the same structure with S7 classes.

## Installation

You can install RSimpleFFI from source using the `remotes` package:

```{r eval=FALSE}
remotes::install_git("sounkou-bioinfo/RSimpleFFI")
```

it requires libffi to be installed on your system (we will vendor libffi in future releases)

```bash
# Ubuntu/Debian
sudo apt-get install libffi-dev

# macOS (via Homebrew)
brew install libffi

# CentOS/RHEL/Fedora
sudo yum install libffi-devel  # or dnf install libffi-devel
```

## Quick Start

```{r}
library(RSimpleFFI)

# Create FFI types
int_type <- ffi_int()
double_type <- ffi_double()

# Get a C function symbol (using built-in test function)
add_func <- ffi_symbol("test_add_int")

# Create call interface (CIF)
cif <- ffi_cif(int_type, int_type, int_type)  # return int, takes two ints

# Call the function
result <- ffi_call(cif, add_func, 15L, 27L)
result
```

## Type System

RSimpleFFI supports many C types including integers, floats, and platform-specific types

### Basic Types
```{r}
void_type <- ffi_void()
int_type <- ffi_int() 
double_type <- ffi_double()
float_type <- ffi_float()
pointer_type <- ffi_pointer()
string_type <- ffi_string()

int8_type <- ffi_int8()
uint8_type <- ffi_uint8()
int16_type <- ffi_int16()
uint16_type <- ffi_uint16()
int32_type <- ffi_int32() 
uint32_type <- ffi_uint32()
int64_type <- ffi_int64()
uint64_type <- ffi_uint64()

size_t_type <- ffi_size_t()
ssize_t_type <- ffi_ssize_t()
long_type <- ffi_long()
ulong_type <- ffi_ulong()

longdouble_type <- ffi_longdouble()
bool_type <- ffi_bool()
wchar_type <- ffi_wchar_t()
```


### Typed Buffers

We can allocate typed buffers using `ffi_alloc()` and read/write data using `ffi_copy_array()` and `ffi_fill_typed_buffer()`

```{r}
# Allocate a buffer for 10 integers
int_type <- ffi_int()
int_buf <- ffi_alloc(int_type, 10L)

# Read back as R vector (using ffi_copy_array)
ffi_copy_array(int_buf, 10L, int_type)

# You can use ffi_alloc for any builtin type:
double_type <- ffi_double()
double_buf <- ffi_alloc(double_type, 5L)
ffi_copy_array(double_buf, 5L, double_type)
```

### Array Types (ArrayType)

Array types can be created using `ffi_array_type()` and used with `ffi_alloc()` and `ffi_copy_array_type()`. They provide a convenient way to handle fixed-size arrays and passed them to C functions via pointers.

```{r}
# Allocate an array of 4 integers
int_type <- ffi_int()
arr_type <- ffi_array_type(int_type, 4L)
arr_ptr <- ffi_alloc(arr_type)

# Write values into the buffer using ffi_fill_typed_buffer
vals <- as.integer(c(10L, 20L, 30L, 40L))
ffi_fill_typed_buffer(arr_ptr, vals, int_type)

# Read back as R vector
result <- ffi_copy_array_type(arr_ptr, arr_type)
result
```


### Struct Types

You can define and use C struct types  using `ffi_struct()`, `ffi_alloc()`, `ffi_get_field()`, and `ffi_set_field()`

```{r}

# Define a struct type: struct Point { int x; double y; }
point_type <- ffi_struct(x = ffi_int(), y = ffi_double())

# use the print methods for no
print(point_type)

# Allocate a struct instance
point_ptr <- ffi_alloc(point_type)

# Set fields
ffi_set_field(point_ptr, "x", 42L, point_type)
ffi_set_field(point_ptr, "y", 3.14, point_type)

# Get fields
x_val <- ffi_get_field(point_ptr, "x", point_type)
y_val <- ffi_get_field(point_ptr, "y", point_type)
x_val 
y_val 
# You can also use integer field indices (1-based):
ffi_set_field(point_ptr, 1L, 100L, point_type)  
ffi_get_field(point_ptr, 2L, point_type)       
```

You can define more complex structs by adding more fields and using any supported FFI type.


## Function Calling

### Basic Function Calls

The package comes with some built-in C test functions for testing, they are defined in [src/test_functions.c](src/test_functions.c)

```{r}
void_func <- ffi_symbol("test_void_function")
void_cif <- ffi_cif(void_type)
ffi_call(void_cif, void_func)

factorial_func <- ffi_symbol("test_factorial")
factorial_cif <- ffi_cif(int_type, int_type)
factorial_result <- ffi_call(factorial_cif, factorial_func, 5L)
factorial_result
```

#### Testing Integer Types

```{r}
# test_int8_func: returns input + 1
int8_func <- ffi_symbol("test_int8_func")
int8_cif <- ffi_cif(int8_type, int8_type)
int8_result <- ffi_call(int8_cif, int8_func, 42L)
int8_result  # 42 + 1 = 43

# test_uint32_func: returns input * 3
uint32_func <- ffi_symbol("test_uint32_func") 
uint32_cif <- ffi_cif(uint32_type, uint32_type)
uint32_result <- ffi_call(uint32_cif, uint32_func, 123L)
uint32_result  # 123 * 3 = 369

# test_int64_func: returns input * 4
int64_func <- ffi_symbol("test_int64_func")
int64_cif <- ffi_cif(int64_type, int64_type)
int64_result <- ffi_call(int64_cif, int64_func, 999L)
int64_result  # 999 * 4 = 3996
```

#### Floating-Point Types

```{r}
add_func <- ffi_symbol("test_add_int")
add_cif <- ffi_cif(int_type, int_type, int_type)
int_result <- ffi_call(add_cif, add_func, 10L, 5L)
int_result

double_func <- ffi_symbol("test_add_double")
double_cif <- ffi_cif(double_type, double_type, double_type)
double_result <- ffi_call(double_cif, double_func, 3.14, 2.86)
double_result

float_func <- ffi_symbol("test_add_float")
float_cif <- ffi_cif(float_type, float_type, float_type)
float_result <- ffi_call(float_cif, float_func, 1.5, 2.5)
float_result
```

#### Struct Types

```{r}
# Define struct type: struct Point { int x; double y; }
point_type <- ffi_struct(x = ffi_int(), y = ffi_double())

# Allocate and set fields
point_ptr <- ffi_alloc(point_type)
ffi_set_field(point_ptr, "x", 42L, point_type)
ffi_set_field(point_ptr, "y", 3.14, point_type)

# Call the built-in C function: int test_get_point_x(Point2D* point)
get_point_x_func <- ffi_symbol("test_get_point_x")
get_point_x_cif <- ffi_cif(ffi_int(), ffi_pointer())
result_x <- ffi_call(get_point_x_cif, get_point_x_func, point_ptr)
result_x  
```
#### Type Conversions

RSimpleFFI attemps to convert between R and C types automatically

```{r}
int16_result <- ffi_call(ffi_cif(int16_type, int16_type), 
                        ffi_symbol("test_int16_func"), 1000L)
int16_result

uint16_result <- ffi_call(ffi_cif(uint16_type, uint16_type),
                         ffi_symbol("test_uint16_func"), 2000.0)
uint16_result

bool_result <- ffi_call(ffi_cif(bool_type, bool_type),
                       ffi_symbol("test_bool_func"), TRUE)
bool_result
```

### Call system libraries functions or external shared libraries

You can load external shared libraries at runtime using RSimpleFFI's `dll_load()` and `dll_ffi_symbol()` functions. These are wrappers around R's native `dyn.load()` facilities that search for shared libraries in system paths when required. 


####  Search so files in system paths


```{r eval=TRUE}
# Example: call the C standard library rand() function
libc_path <- dll_load_system("libgcc_s.so.1")
rand_func <- dll_ffi_symbol("rand", ffi_int())
rand_value <- rand_func()
rand_value
dll_unload(libc_path)
```

#### Explicitly load shared libraries 

```{r eval=TRUE}
# Find the libc shared object (libc is always present)
so_files <- list.files("/lib/x86_64-linux-gnu", pattern = "^libc[.]so[.]6$", full.names = TRUE)
if (length(so_files) == 0) stop("libc.so.6 not found")
lib_path <- dll_load(so_files[1])

# Allocate a buffer of 8 bytes
raw_type <- ffi_raw()
buf_ptr <- ffi_alloc(raw_type, 8L)
rawToChar(ffi_copy_array(buf_ptr, 8L, raw_type))
# Get memset from libc: void *memset(void *s, int c, size_t n)
memset_fn <- dll_ffi_symbol("memset", ffi_pointer(), ffi_pointer(), ffi_int(), ffi_size_t())

# Fill the buffer with ASCII 'A' (0x41)
memset_fn(buf_ptr, as.integer(0x41), 8L)

# Read back the buffer and print as string
rawToChar(ffi_copy_array(buf_ptr, 8L, raw_type))

dll_unload(lib_path)
```


### Compile and Load C Code

The package provides facilities to load C code on the fly. The compiler uses R CMD SHLIB under the hood

```{r}
c_code <- '
int add_numbers(int a, int b) {
    return a + b;
}
'

lib_path <- dll_compile_and_load(c_code, "example_lib")
int_t <- ffi_int()
add_fn <- dll_ffi_symbol("add_numbers", int_t, int_t, int_t)
result <- add_fn(10L, 5L)
result

dll_unload(lib_path)
```

```{r}
math_code <- '
#include <math.h>
double compute_distance(double x1, double y1, double x2, double y2) {
    double dx = x2 - x1;
    double dy = y2 - y1;
    return sqrt(dx*dx + dy*dy);
}
'

lib_path <- dll_compile_and_load(math_code, "math_lib", libs = "m")
double_t <- ffi_double()
distance_fn <- dll_ffi_symbol("compute_distance", double_t, double_t, double_t, double_t, double_t)
dist <- distance_fn(0.0, 0.0, 3.0, 4.0)
dist

dll_unload(lib_path)
```

## Benchmarking

We run some benchmarks to estimate the performance of FFI calls (i.e the overhead of calling C functions from R using RSimpleFFI) compared to native R C built-in functions.


### R builtin C functions
```{r}

set.seed(123)
n <- 10000
x_vec <- runif(n, 1, 100)
x_ptr <- ffi_alloc(ffi_double(), n)
ffi_fill_typed_buffer(x_ptr, x_vec, ffi_double())
out_ptr <- ffi_alloc(ffi_double(), n)

math_code <- '
#include <math.h>
void vec_sqrt(const double* x, double* out, int n) {
    for (int i = 0; i < n; ++i) out[i] = sqrt(x[i]);
}
'
lib_path <- dll_compile_and_load(math_code, "bench_vec", libs = "m", cflags = "-O3")
vec_sqrt_func <- dll_ffi_symbol("vec_sqrt", ffi_void(), ffi_pointer(), ffi_pointer(), ffi_int())

benchmark_result <- bench::mark(
  native_r = sqrt(x_vec),
  ffi_call = { vec_sqrt_func(x_ptr, out_ptr, n); ffi_copy_array(out_ptr, n, ffi_double()) },
  check = FALSE,
  iterations = 100
)
benchmark_result
dll_unload(lib_path)
```

### Interpreted R Code 
We compare a pure C convolution (via FFI) to a simple R implementation.

```{r}
# Slow R convolution
slow_convolve <- function(a, b) {
  ab <- double(length(a) + length(b) - 1)
  for (i in seq_along(a)) {
    for (j in seq_along(b)) {
      ab[i+j-1] <- ab[i+j-1] + a[i] * b[j]
    }
  }
  ab
}

# C code for convolution (valid for FFI)
conv_code <- '
void c_convolve(const double* signal, int n_signal, const double* kernel, int n_kernel, double* out) {
    int n_out = n_signal + n_kernel - 1;
    for (int i = 0; i < n_out; ++i) {
        out[i] = 0.0;
        for (int j = 0; j < n_kernel; ++j) {
            int k = i - j;
            if (k >= 0 && k < n_signal) {
                out[i] += signal[k] * kernel[j];
            }
        }
    }
}
'

set.seed(42)
signal <- rnorm(10000)
kernel <- c(0.2, 0.5, 0.3)
n_signal <- length(signal)
n_kernel <- length(kernel)
n_out <- n_signal + n_kernel - 1

# Allocate buffers for FFI
signal_ptr <- ffi_alloc(ffi_double(), n_signal)
kernel_ptr <- ffi_alloc(ffi_double(), n_kernel)
out_ptr <- ffi_alloc(ffi_double(), n_out)
ffi_fill_typed_buffer(signal_ptr, signal, ffi_double())
ffi_fill_typed_buffer(kernel_ptr, kernel, ffi_double())

# Compile and load C convolution
lib_path <- dll_compile_and_load(conv_code, "bench_conv", cflags = "-O3")
c_conv_fn <- dll_ffi_symbol("c_convolve", ffi_void(), ffi_pointer(), ffi_int(), ffi_pointer(), ffi_int(), ffi_pointer())

# Run C convolution via FFI
c_conv_fn(signal_ptr, n_signal, kernel_ptr, n_kernel, out_ptr)
c_result <- ffi_copy_array(out_ptr, n_out, ffi_double())

# Run R convolution
r_result <- slow_convolve(signal, kernel)

# Check results are similar
all.equal(as.numeric(c_result), as.numeric(r_result))

# Benchmark
benchmark_result <- bench::mark(
  r = slow_convolve(signal, kernel),
  c_ffi = { c_conv_fn(signal_ptr, n_signal, kernel_ptr, n_kernel, out_ptr); ffi_copy_array(out_ptr, n_out, ffi_double()) },
  check = FALSE,
  iterations = 20
)
benchmark_result
dll_unload(lib_path)
```

## Limitations and issues

Right now there are unimplemented features and limitations including uncessary copying, lack of protection and several potential memory leaks. The interface can and should be refined further. Our types are C pointers never collected. Furthermore we will vendor libffi in future releases to avoid dependency issues.

## License

This project is licensed under the GPL-3 License.
