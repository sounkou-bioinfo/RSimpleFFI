% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/01-functions.R
\name{ffi_closure}
\alias{ffi_closure}
\title{Create an FFI closure from an R function}
\usage{
ffi_closure(r_function, return_type, ...)
}
\arguments{
\item{r_function}{An R function to wrap as a callback}

\item{return_type}{FFIType for return value}

\item{...}{FFIType objects for arguments}
}
\value{
An FFIClosure object
}
\description{
Wraps an R function so it can be used as a callback from C code.
The closure has a CIF that describes its signature (return type and
argument types). When C code calls through the closure's function
pointer, the R function is invoked with converted arguments.
}
\details{
The R function must accept the same number of arguments as specified
in the type signature. Arguments are converted from C types to R types
before calling, and the return value is converted back to C.

Important: You must keep a reference to the FFIClosure object for as
long as C code might call through it. If the closure is garbage collected,
calling through its function pointer will crash.
}
\examples{
\dontrun{
# Create a comparison function for qsort
cmp_fn <- function(a, b) {
  as.integer(a - b)
}

# Wrap it as a C callback: int (*)(int*, int*)
cmp_closure <- ffi_closure(
  cmp_fn,
  ffi_int(), # return type
  ffi_pointer(), ffi_pointer() # argument types (pointers to int)
)

# Get the function pointer to pass to C
cmp_ptr <- ffi_closure_pointer(cmp_closure)
}

}
\seealso{
\code{\link[=ffi_closure_pointer]{ffi_closure_pointer()}} to get the callable function pointer
}
