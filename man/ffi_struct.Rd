% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/00-types.R
\name{ffi_struct}
\alias{ffi_struct}
\title{Create FFI structure type}
\usage{
ffi_struct(..., pack = NULL)
}
\arguments{
\item{...}{Named FFIType objects representing struct fields}

\item{pack}{Integer specifying packing alignment (1, 2, 4, 8, or 16), or NULL
for default/natural alignment. When pack=1, fields are byte-aligned (no padding).}
}
\value{
StructType object
}
\description{
Creates an FFI structure type from named field types. By default, libffi
uses natural alignment (each field aligned to its size). Use the \code{pack}
parameter to specify tighter packing similar to \verb{#pragma pack(n)} in C.
}
\section{Packing and libffi}{

The \code{pack} parameter affects how \code{ffi_offsetof()}, \code{ffi_sizeof()},
\code{ffi_get_field()}, and \code{ffi_set_field()} calculate field offsets and struct size.
This is useful when working with memory buffers that use packed C structs.

\strong{Important}: libffi internally always uses natural alignment when passing
structs by value in function calls. Packed structs work correctly when:
\itemize{
\item Reading/writing to memory buffers (ffi_alloc, ffi_get_field, ffi_set_field)
\item Passing struct pointers to C functions (the C code handles the packed layout)
\item Computing offsets for manual memory manipulation
}

However, passing a packed struct \strong{by value} to ffi_call may not work correctly
because libffi will use natural alignment for the call.
}

\examples{
# Natural alignment (default)
Point <- ffi_struct(x = ffi_int(), y = ffi_int())

# Packed struct (1-byte alignment)
PackedData <- ffi_struct(
  flag = ffi_uint8(),
  value = ffi_int32(),
  pack = 1
)

# Check sizes
ffi_sizeof(Point) # Natural size
ffi_sizeof(PackedData) # Packed size (smaller)
}
\keyword{Types}
